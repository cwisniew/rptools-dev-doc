(self.webpackChunkmaptool_dev_doc=self.webpackChunkmaptool_dev_doc||[]).push([[805],{33005:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return h},metadata:function(){return d},toc:function(){return c},default:function(){return p}});var a=t(87462),r=t(63366),o=(t(67294),t(3905)),s=t(93456),i=["components"],l={},h="Handshake and Authentication",d={unversionedId:"authentication/handshake",id:"authentication/handshake",isDocsHomePage:!1,title:"Handshake and Authentication",description:"Last Updated: MapTool 1.10",source:"@site/docs/authentication/handshake.md",sourceDirName:"authentication",slug:"/authentication/handshake",permalink:"/docs/authentication/handshake",editUrl:"https://github.com/cwisniew/rptools-dev-doc/edit/main/docs/authentication/handshake.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"RPTools Development Documentation Intro",permalink:"/docs/intro"},next:{title:"MapTool Road Map",permalink:"/docs/roadmap/index"}},c=[{value:"Blocked Player",id:"blocked-player",children:[]},{value:"Player using public key authentication",id:"player-using-public-key-authentication",children:[]},{value:"Player using shared password authentication",id:"player-using-shared-password-authentication",children:[]},{value:"Protocol Buffers",id:"protocol-buffers",children:[]}],u={toc:c};function p(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"handshake-and-authentication"},"Handshake and Authentication"),(0,o.kt)("p",null,"Last Updated: MapTool 1.10"),(0,o.kt)("p",null,"The handshake and authentication occurs via protocol buffers messages before any Hessian serialization occurs. Once the handshake and authentication is successful only then will Hessian serialization be used for passing messages between server and client. (This is likely to change in MapTool 1.11 or MapTool 1.12 where Hessian will be completely replaced by protocol buffers)"),(0,o.kt)("h2",{id:"blocked-player"},"Blocked Player"),(0,o.kt)("p",null,"If a player is blocked then the Server will inform the client of this before trying perform any password or public key authentication."),(0,o.kt)(s.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>\n    Server->>Client: Send PlayerBlockedMsg\n    Client->>Client: Inform Player<br/>and disconnect.",mdxType:"Mermaid"}),(0,o.kt)("h2",{id:"player-using-public-key-authentication"},"Player using public key authentication"),(0,o.kt)("p",null,"If the player is not blocked and is authenticating with a public key then the following authentication/handshake sequence occurs. The public key has to be known to the Server before a player can attempt to authenticate this way."),(0,o.kt)("p",null,"The public key is never sent from client to server via MapTool so the server must know of the public key before hand. The server then encrypts the handshake challenge using the public key which the client will only be able to decrypt if it has access to the matching private key, once decrypted the client sends back the handshake challenge in plaintext as it needs to do no more to show it has the correct private key."),(0,o.kt)(s.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>and retrieve password salt\n    Server->>Server: Create HandshakeChallenge\n    Server->>Server: Encrypt Challenge with public key\n    Server->>Client: Send UseAuthTypeMsg\n    Note right of Server: auth_type = ASYMMETRIC_KEY<br/> challenge[0] = HandshakeChallenge.challenge\n    Client->>Client: Decrypt Handshake Challenge\n    Client->>Server: Send ClientAuthMsg\n    Note left of Client:(not encrypted)<br/>challenge_response = HandshakeChallenge.response\n    Server->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,o.kt)("h2",{id:"player-using-shared-password-authentication"},"Player using shared password authentication"),(0,o.kt)("p",null,"If the player is not blocked and is authenticating with a shared password the following authentication/handshake sequence occurs. As a shared password could be per player or role based (i.e. a single password for players and another single password for GMs) the server creates a challenge for both GM and Player and which ever the client can respond to determines the role. If a password database is used where the role is recorded and the Server knows if the player is a GM or not then a new random password will be used to encrypt the non pertinent handshake challenge ensuring it should never match."),(0,o.kt)("p",null,"Password information is never sent between the client and the server instead it is used on both sides to encrypt/decrypt the handshake challenge."),(0,o.kt)(s.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n  Client->>Server: ClientInitMsg\nServer->>Server: Lookup Player from ClientInitMsg and<br/>retrieve password salt\nServer->>Server: Create HandshakeChallenge<br/>Player Password\nnote right of Server: If using player database<br/> with known players and player<br/>is GM then a new random<br/>password is used so this<br/> would never match.\nServer->>Server: Create HandshakeChallenge<br/>GM Password\nnote right of Server: If using player database<br/> with known players and player<br/>is not a GM then a new random<br/>password is used so this<br/> would never match.\nServer->>Client: Send UseAuthTypeMsg\nnote right of Client: auth_type = SHARED_PASSWORD<br/> salt = retrieved password salt<br/> challenge[0] = HandshakeChallenge.challenge (gm)<br/> challenge[1] = HandshakeChallenge.challenge (player)<br/>\nClient->>Client: Hash password with<br/>PBKDF2WithHmacSHA1<br/>using salt sent by Server\nClient->>Client: Try decrypt both challenges\nClient->>Client: Encrypt HandshakeChallenge.response\nClient->>Server: Send ClientAuthMsg\nnote right of Server: challenge_response = Encrypted HandshakeChallenge.response\nServer->>Server: Compare client challenge response to<br/>pre-encrypted challenge response on server<br/>side to determine which password was used\nServer->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,o.kt)("h2",{id:"protocol-buffers"},"Protocol Buffers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf",metastring:'reference title="Handshake Protocol Buffers"',reference:!0,title:'"Handshake',Protocol:!0,'Buffers"':!0},"https://github.com/RPTools/maptool/blob/develop/src/main/proto/handshake.proto\n")))}p.isMDXComponent=!0},11748:function(e,n,t){var a={"./locale":89234,"./locale.js":89234};function r(e){var n=o(e);return t(n)}function o(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=o,e.exports=r,r.id=11748}}]);