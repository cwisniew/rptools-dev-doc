(self.webpackChunkmaptool_dev_doc=self.webpackChunkmaptool_dev_doc||[]).push([[805],{33005:function(e,n,a){"use strict";a.r(n),a.d(n,{frontMatter:function(){return l},contentTitle:function(){return h},metadata:function(){return d},toc:function(){return c},default:function(){return p}});var t=a(87462),r=a(63366),o=(a(67294),a(3905)),i=a(93456),s=["components"],l={},h="Handshake and Authentication",d={unversionedId:"authentication/handshake",id:"authentication/handshake",isDocsHomePage:!1,title:"Handshake and Authentication",description:"Last Updated: MapTool 1.10",source:"@site/docs/authentication/handshake.md",sourceDirName:"authentication",slug:"/authentication/handshake",permalink:"/docs/authentication/handshake",editUrl:"https://github.com/cwisniew/rptools-dev-doc/edit/main/docs/authentication/handshake.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"RPTools Development Doctunation Intro",permalink:"/docs/intro"}},c=[{value:"Blocked Player",id:"blocked-player",children:[]},{value:"Player using public key authentication",id:"player-using-public-key-authentication",children:[]},{value:"Player using shared password authentication",id:"player-using-shared-password-authentication",children:[]},{value:"Protocal Buffers",id:"protocal-buffers",children:[]}],u={toc:c};function p(e){var n=e.components,a=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"handshake-and-authentication"},"Handshake and Authentication"),(0,o.kt)("p",null,"Last Updated: MapTool 1.10"),(0,o.kt)("p",null,"The handshake and authentication occurs via protobuf messages before any Hessian serialization occurs. Once the handshake and authentication is succcessful only then will Hessian serialization be used for passing messages between server and client. (This is likely to change in MapTool 1.11 or MapTool 1.12 where Hessian will be completely replaced by protobuf)"),(0,o.kt)("h2",{id:"blocked-player"},"Blocked Player"),(0,o.kt)("p",null,"If a player is blocked then the Server will inform the client of this before trying perform any password or public key authentication."),(0,o.kt)(i.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>\n    Server->>Client: Send PlayerBlockedMsg\n    Client->>Client: Inform Player<br/>and disconnect.",mdxType:"Mermaid"}),(0,o.kt)("h2",{id:"player-using-public-key-authentication"},"Player using public key authentication"),(0,o.kt)("p",null,"If the player is not blocked and is authenticating with a public key then the following authentication/handshake sequence occurs. The public key has to be known to the Server before a player can attempt to authenticat this way."),(0,o.kt)(i.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n    Client->>Server: ClientInitMsg\n    Server->>Server: Lookup Player from ClientInitMsg<br/>and retrieve password salt\n    Server->>Server: Create HandshakeChallenge\n    Server->>Server: Encrypt Challenge with public key\n    Server->>Client: Send UseAuthTypeMsg\n    Note right of Server: auth_type = ASYMMETRIC_KEY<br/> challenge[0] = HandshakeChallenge.challenge\n    Client->>Client: Decrypt Handshake Challenge\n    Client->>Server: Send ClientAuthMsg\n    Note left of Client:(not encrypted)<br/>challenge_response = HanshakeChallenge.response\n    Server->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,o.kt)("h2",{id:"player-using-shared-password-authentication"},"Player using shared password authentication"),(0,o.kt)("p",null,"If the player is not blocked and is authentiating with a shared password the following authentication/handsake squence occurs. As a shared password could be per player or role based (i.e. a single password for players and another single password for GMs) the server creates a challenge for both GM and Player and which ever the client can respond to determines the role. If a password database is used where the role is recorded and the Server knows if the player is a GM or not then a new random password will be used to encrypt the non pertinant handshake challenge ensureing it should never match."),(0,o.kt)(i.Mermaid,{chart:"\n%%{init: {'theme': 'base', 'themeVariables': { 'signalColor': '#e0081a', 'textColor': '#e0081a' }}}%%\n  sequenceDiagram\n  Client->>Server: ClientInitMsg\nServer->>Server: Lookup Player from ClientInitMsg and<br/>retrieve password salt\nServer->>Server: Create HandshakeChallenge<br/>Player Password\nnote right of Server: If using player database<br/> with known players and player<br/>is GM then a new random<br/>password is used so this<br/> would never match.\nServer->>Server: Create HandshakeChallenge<br/>GM Password\nnote right of Server: If using player database<br/> with known players and player<br/>is not a GM then a new random<br/>password is used so this<br/> would never match.\nServer->>Client: Send UseAuthTypeMsg\nnote right of Client: auth_type = SHARED_PASSWORD<br/> salt = retrieved password salt<br/> challenge[0] = HandshakeChallenge.challenge (gm)<br/> challenge[1] = HandshakeChallenge.challenge (player)<br/>\nClient->>Client: Hash password with<br/>PBKDF2WithHmacSHA1<br/>using salt sent by Server\nClient->>Client: Try decrypt both challenges\nClient->>Client: Encrypt HandshakeChallenge.response\nClient->>Server: Send ClientAuthMsg\nnote right of Server: challenge_response = Encrypted HandshakeChallenge.response\nServer->>Server: Compare client challenge response to<br/>preencrypted challenge response on server<br/>side to determine which password was used\nServer->>Client: Send ConnectionSuccessfulMsg",mdxType:"Mermaid"}),(0,o.kt)("h2",{id:"protocal-buffers"},"Protocal Buffers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf",metastring:'reference title="Handshake Protocal Buffers"',reference:!0,title:'"Handshake',Protocal:!0,'Buffers"':!0},"https://github.com/RPTools/maptool/blob/develop/src/main/proto/handshake.proto\n")))}p.isMDXComponent=!0},11748:function(e,n,a){var t={"./locale":89234,"./locale.js":89234};function r(e){var n=o(e);return a(n)}function o(e){if(!a.o(t,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return t[e]}r.keys=function(){return Object.keys(t)},r.resolve=o,e.exports=r,r.id=11748}}]);